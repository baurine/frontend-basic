<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>D3 Example</title>
    <script src="http://d3js.org/d3.v5.min.js"></script>
    <style>
      .axis text {
        font-weight: bold;
      }
      .y-axis text {
        /* y 轴文字靠右对齐 */
        text-anchor: end;
      }
      .axis path {
        /* 隐藏 path */
        display: none;
      }
      .axis line {
        /* 降低 tick 的可视度 */
        stroke-opacity: 0.3;
      }
      .line {
        fill: none;
        stroke: steelblue;
        stroke-width: 1.5px;
      }
    </style>
  </head>
  <body>
    <svg></svg>
    <script>
      d3.csv(
        // 'https://raw.githubusercontent.com/levvsha/d3-in-all-its-glory-en/master/stats/data.csv'
        '/data/misc-glory-data.csv'
      ).then(data => draw(data))

      // function ticks() {
      //   console.log(arguments) // [5, callee: f, ...]
      //   console.log(Array.prototype.slice.call(arguments))
      // }
      // ticks(5) // [5]
      // ticks(5, 6) // [5,6]
      // ticks([5, 6]) // [[5,6]]

      function draw(data) {
        // data:
        // [
        //   {regionId: "1", regionName: "Ryazan Oblast", date: "2001-01-01T00:00:00", percent: "26.5000"}
        //   ...
        // ]
        // console.log(data)

        // 准备尺寸和 scale
        const outWidth = 750
        const outHeight = 420
        const margin = { top: 20, right: 20, bottom: 50, left: 50 }
        const inWidth = outWidth - margin.left - margin.right
        const inHeight = outHeight - margin.top - margin.bottom
        const x = d3.scaleTime().range([0, inWidth])
        const y = d3.scaleLinear().range([inHeight, 0])
        const svg = d3
          .select('svg')
          .attr('width', outWidth)
          .attr('height', outHeight)
          .append('g')
          .attr('transform', `translate(${margin.left}, ${margin.top})`) // 移动到绘图区的起点

        // color scale
        const colorScale = d3
          .scaleOrdinal()
          .range([
            '#4c78a8',
            '#9ecae9',
            '#f58518',
            '#ffbf79',
            '#54a24b',
            '#88d27a',
            '#b79a20',
            '#439894',
            '#83bcb6',
            '#e45756',
            '#ff9d98',
            '#79706e',
            '#bab0ac',
            '#d67195',
            '#fcbfd2',
            '#b279a2',
            '#9e765f',
            '#d8b5a5'
          ])

        // 处理 data 和 scale
        data.forEach(d => {
          d.date = new Date(d.date)
          d.percent = +d.percent
        })
        x.domain(d3.extent(data, d => d.date)) // d3.extent = (array) => [min, max]
        y.domain([0, d3.max(data, d => d.percent)])
        colorScale.domain(d3.map(data, d => d.regionId).keys())

        // 绘制坐标轴
        // 坐标轴由 path/line/text 三种 svg 元素组成
        // path 是轴，line 是与轴垂直的 tick，text 是标签
        // axisBottom 表示默认文字在 path 之下，并不表示是底部的 x 轴
        // axisRight 表示默认文字在 path 右边，并不表示是右边的 y 轴
        // axisTop 表示默认文字在 path 上边
        // axisLeft 表示默认文辽在 path 左边
        console.log(((inWidth + 2) / (inHeight + 2)) * 5)
        const xAxis = d3
          .axisBottom(x)
          .ticks(((inWidth + 2) / (inHeight + 2)) * 5) // 这个算出是约为 10，但实际绘出来为什么有 14 个点啊 (http://pkuwwt.github.io/d3-tutorial-cn/axes.html，这篇文章说 ticks() 只是建议，d3 会根据实际情况自行调整)
          .tickSize(-inHeight - 6) // 还可以负数？猜测这个 tickSize 表示 tick 的长度，负值表示往 y 轴上方扩展，形成网格
          .tickPadding(10) // 从源码看，padding 是坐标轴上文字和 path 的距离
        const yAxis = d3
          .axisRight(y) // 为什么是 right 而不是 left，因为 right 并不表示右边的 y 轴，只表示文字默认在右边
          .ticks(5)
          .tickSize(7 + inWidth) // 往 x 轴方向扩展的长度
          .tickPadding(-15 - inWidth) // 文字和竖线的距离，实际 padding: 7 + inWidth -15 - inWidth = -8，源码：spacing = Math.max(tickSizeInner, 0) + tickPadding,
          .tickFormat(d => d + '%')
        // 是否等同，测试了，效果基本一样，甚至还要好一些，文字对齐的更好
        // const yAxis = d3
        //   .axisLeft(y)
        //   .ticks(5)
        //   .tickSize(-7 - inWidth)
        //   .tickPadding(8)
        //   .tickFormat(d => d + '%')

        svg
          .append('g')
          .attr('class', 'axis x-axis')
          .attr('transform', `translate(0, ${inHeight + 6})`)
          .call(xAxis)
        svg
          .append('g')
          .attr('class', 'axis y-axis')
          .attr('transform', 'translate(-7, 0)')
          .call(yAxis)

        // 单独绘制两条轴的 path，上面两条轴的 path 在 style 中用 `display: none` 隐藏了
        svg
          .append('g')
          .attr('transform', `translate(0, ${inHeight})`)
          .call(d3.axisBottom(x).ticks(0))
        svg.append('g').call(d3.axisLeft(y).ticks(0))

        ////////////////////////////////
        // step 2
        // 按 regionId 进行分组，相同 regionId 的元素聚合在一起
        const nestByRegionId = d3
          .nest()
          .key(d => d.regionId)
          .sortKeys((v1, v2) => (parseInt(v1, 10) > parseInt(v2, 10) ? 1 : -1))
          .entries(data)
        // [{key: "1", values: [{regionId: "1", regionName: ..., date: ..., precent: ...}, {regionId: "1", ...} ]}]
        console.log(nestByRegionId)

        const regions = {}
        // d3.map(data, d => d.regionId)
        //   .keys() // 这个方法去重了?
        //   .forEach(function(d, i) {
        //     regions[d] = nestByRegionId[i].values // 总觉得这逻辑不对啊
        //   })
        // console.log(d3.map(data, d => d.regionId)) // 结果有点意外
        // console.log(d3.map(data, d => d.regionId).keys()) // ["1", "5", "9" ...]
        // console.log(regions) // {1: [...], 5: [...]}
        // const regionIds = Object.keys(regions)
        const regionIds = nestByRegionId.map(item => item.key)
        nestByRegionId.forEach(item => {
          regions[item.key] = item.values
        })

        // path 生成器
        const lineGenerator = d3
          .line()
          .x(d => x(d.date))
          .y(d => y(d.percent))
        svg
          .selectAll('.line')
          .data(regionIds)
          .enter()
          .append('path')
          .attr('class', 'line')
          .attr('id', regionId => `region-${regionId}`)
          .attr('d', regionId => lineGenerator(regions[regionId]))
          .style('stroke', regionId => colorScale(regionId))
        // .style('fill', 'none')
      }
    </script>
  </body>
</html>
